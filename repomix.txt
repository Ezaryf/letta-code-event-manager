This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.githooks/pre-commit
.github/workflows/letta-comment.yml
.gitignore
agents/debugger.agent.json
agents/refactorer.agent.json
agents/reviewer.agent.json
agents/tester.agent.json
config/letta.json
mapping.json
memory/long_term.json
memory/short_term.json
package.json
run-demo.ps1
scripts/autoFixLoop.js
scripts/createAgent.js
scripts/dispatch-cli.js
scripts/dispatcher.js
scripts/generateCommitMsg.js
scripts/memory.js
scripts/remember.js
scripts/router.js
scripts/selector.js
scripts/sendMessage.js
scripts/watcher.js
templates/ci_failure.txt
templates/formatting.txt
templates/lint.txt
templates/refactor.txt
templates/runtime.txt
templates/test_failure.txt
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path=".githooks/pre-commit">
#!/usr/bin/env bash
set -e

echo "Running tests..."
npm test || { echo "Tests failed. Aborting commit."; exit 1; }

# Create a short description from staged diff
desc=$(git diff --staged --name-only | head -n 1)
if [ -z "$desc" ]; then
  desc="update"
fi

node scripts/generateCommitMsg.js "$desc"
echo "Commit message prepared (use: git commit -F .git_commit_message.txt)"
exit 0
</file>

<file path=".github/workflows/letta-comment.yml">
name: Letta Assistant (Read-only)

on:
  pull_request:
    types: [opened, synchronize]

jobs:
  letta:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: "20"

      - name: Install dependencies
        run: npm ci

      - name: Collect CI context
        run: |
          echo "PR Title: ${{ github.event.pull_request.title }}" > context.txt
          echo "PR Author: ${{ github.actor }}" >> context.txt
          echo "Changed files:" >> context.txt
          git diff --name-only ${{ github.event.pull_request.base.sha }} >> context.txt

      - name: Generate Letta message
        run: |
          node scripts/sendMessage.js ci_failure context.txt > letta_message.txt 2>&1 || true

      - name: Comment on PR
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require("fs");
            const body = fs.readFileSync("letta_message.txt", "utf8");

            github.rest.issues.createComment({
              issue_number: context.issue.number,
              owner: context.repo.owner,
              repo: context.repo.repo,
              body: "ü§ñ **Letta Analysis (read-only)**\n\n```\n" + body + "\n```"
            });
</file>

<file path=".gitignore">
.env
node_modules/
.letta_agent_id
.git_commit_message.txt
suggestions/
</file>

<file path="agents/debugger.agent.json">
{
  "role": "debugger",
  "goal": "Find root causes of failures",
  "output": ["diagnosis", "fix"],
  "instructions": "Analyze errors carefully, identify root cause, suggest minimal safe fixes"
}
</file>

<file path="agents/refactorer.agent.json">
{
  "role": "refactorer",
  "goal": "Improve code structure without changing behavior",
  "output": ["refactored_code", "explanation"],
  "instructions": "Suggest cleaner code patterns while preserving exact functionality"
}
</file>

<file path="agents/reviewer.agent.json">
{
  "role": "reviewer",
  "goal": "Check safety and correctness",
  "output": ["risks", "improvements"],
  "instructions": "Review proposed changes for safety, correctness, and potential side effects"
}
</file>

<file path="agents/tester.agent.json">
{
  "role": "tester",
  "goal": "Analyze test failures and suggest fixes",
  "output": ["failing_tests", "fix_suggestions"],
  "instructions": "Parse test output, identify failing assertions, suggest targeted fixes"
}
</file>

<file path="config/letta.json">
{
  "endpoint": "https://api.letta.ai/v1/messages",
  "model": "letta-core",
  "temperature": 0.2
}
</file>

<file path="mapping.json">
{
  "test_failure": "templates/test_failure.txt",
  "lint_error": "templates/lint.txt",
  "runtime_error": "templates/runtime.txt",
  "refactor_request": "templates/refactor.txt",
  "formatting_issue": "templates/formatting.txt",
  "ci_failure": "templates/ci_failure.txt"
}
</file>

<file path="memory/long_term.json">
{
  "project_type": "Node.js backend",
  "testing_framework": "jest",
  "style": "functional, readable",
  "common_failures": []
}
</file>

<file path="memory/short_term.json">
[]
</file>

<file path="package.json">
{
  "name": "letta-code-event-manager",
  "version": "1.0.0",
  "type": "module",
  "main": "index.js",
  "scripts": {
    "test": "echo \"Error: no test specified\" && exit 1",
    "create-agent": "node scripts/createAgent.js",
    "send": "node scripts/sendMessage.js",
    "remember": "node scripts/remember.js",
    "commit-msg": "node scripts/generateCommitMsg.js",
    "watch": "node scripts/watcher.js",
    "dispatch": "node scripts/dispatcher.js",
    "dispatch-cli": "node scripts/dispatch-cli.js",
    "auto-fix": "node scripts/autoFixLoop.js",
    "route": "node scripts/router.js",
    "memory": "node scripts/memory.js show"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "description": "Letta-powered autonomous development assistant",
  "dependencies": {
    "@letta-ai/letta-client": "^1.6.2",
    "chokidar": "^5.0.0",
    "dayjs": "^1.11.19",
    "dotenv": "^17.2.3",
    "fs-extra": "^11.3.3",
    "minimatch": "^10.1.1",
    "node-fetch": "^3.3.2"
  }
}
</file>

<file path="run-demo.ps1">
# run-demo.ps1
# One-shot demo: capture test output from your project, dispatch to Letta, view suggestion

param(
  [string]$LettaRepo = "C:\Users\ezary\OneDrive\Documents\Coding-Language\letta-code-event-manager",
  [string]$ProjectRepo = "C:\Users\ezary\OneDrive\Documents\Coding-Language\warisan-pahlawan-bakti-website\malaysia-member-card",
  [string]$TestCommand = "npm test"
)

Write-Host "========================================" -ForegroundColor Cyan
Write-Host "  LETTA DEMO - Real Project Integration" -ForegroundColor Cyan
Write-Host "========================================" -ForegroundColor Cyan
Write-Host ""
Write-Host "Letta repo:    $LettaRepo" -ForegroundColor Yellow
Write-Host "Project repo:  $ProjectRepo" -ForegroundColor Yellow
Write-Host "Test command:  $TestCommand" -ForegroundColor Yellow
Write-Host ""

# Ensure events folder exists
$eventsDir = Join-Path $LettaRepo "events"
if (-not (Test-Path $eventsDir)) {
  New-Item -ItemType Directory -Path $eventsDir | Out-Null
  Write-Host "Created events directory: $eventsDir" -ForegroundColor Green
}

# Create a timestamped event filename
$stamp = Get-Date -Format "yyyyMMdd_HHmmss"
$eventFile = Join-Path $eventsDir "project_test_$stamp.log"

Write-Host ""
Write-Host "Step 1: Running tests in project..." -ForegroundColor Cyan
Write-Host "Output will be saved to: $eventFile" -ForegroundColor Gray

# Run the test command in the project and capture stdout+stderr
Push-Location $ProjectRepo
try {
  # Capture ALL output (stdout & stderr)
  $output = & cmd /c "$TestCommand 2>&1"
  $output | Out-File -FilePath $eventFile -Encoding utf8
  Write-Host "Test output captured successfully." -ForegroundColor Green
} catch {
  Write-Host "Test command exited with error; output saved to event file." -ForegroundColor Yellow
}
Pop-Location

# Show preview of captured output
Write-Host ""
Write-Host "---- TEST OUTPUT PREVIEW (first 20 lines) ----" -ForegroundColor Magenta
Get-Content $eventFile -TotalCount 20 | Write-Host

# Dispatch event to Letta
Write-Host ""
Write-Host "Step 2: Dispatching event to Letta..." -ForegroundColor Cyan
Push-Location $LettaRepo
node .\scripts\dispatch-cli.js $eventFile $ProjectRepo

# Find latest suggestion directory
$suggestionsRoot = Join-Path $LettaRepo "suggestions"
if (-not (Test-Path $suggestionsRoot)) {
  Write-Host "No suggestions folder found. Dispatch may have failed." -ForegroundColor Red
  Pop-Location
  exit 1
}

$latest = Get-ChildItem $suggestionsRoot -Directory | Sort-Object Name | Select-Object -Last 1
if (-not $latest) {
  Write-Host "No suggestion directories found." -ForegroundColor Red
  Pop-Location
  exit 1
}

Write-Host ""
Write-Host "Step 3: Reviewing Letta's suggestion..." -ForegroundColor Cyan
Write-Host "Suggestion folder: $($latest.FullName)" -ForegroundColor Green

Write-Host ""
Write-Host "======== AGENT RESPONSE ========" -ForegroundColor Yellow
$responsePath = Join-Path $latest.FullName "agent-response.txt"
if (Test-Path $responsePath) {
  Get-Content $responsePath | Write-Host
} else {
  Write-Host "(No response file found)" -ForegroundColor Gray
}

Write-Host ""
Write-Host "======== SUGGESTED PATCH ========" -ForegroundColor Yellow
$patchPath = Join-Path $latest.FullName "suggested.patch"
if (Test-Path $patchPath) {
  Get-Content $patchPath | Write-Host
} else {
  Write-Host "(No patch suggested)" -ForegroundColor Gray
}

Write-Host ""
Write-Host "======== BEST PRACTICES ========" -ForegroundColor Yellow
$bpPath = Join-Path $latest.FullName "best-practices.txt"
if (Test-Path $bpPath) {
  Get-Content $bpPath | Write-Host
} else {
  Write-Host "(No best practices noted)" -ForegroundColor Gray
}

# Open the folder in Explorer
Write-Host ""
Write-Host "Opening suggestion folder in Explorer..." -ForegroundColor Cyan
Start-Process explorer.exe $latest.FullName

Pop-Location

Write-Host ""
Write-Host "========================================" -ForegroundColor Green
Write-Host "  DEMO COMPLETE" -ForegroundColor Green
Write-Host "========================================" -ForegroundColor Green
Write-Host ""
Write-Host "Next steps:" -ForegroundColor Yellow
Write-Host "  1. Review the agent response above"
Write-Host "  2. If there's a patch, copy it to your project:"
Write-Host "     Copy-Item '$patchPath' '$ProjectRepo\fix.patch'"
Write-Host "  3. Check the patch: git apply --check fix.patch"
Write-Host "  4. Apply if safe: git apply fix.patch"
Write-Host "  5. Run tests again: npm test"
Write-Host ""
</file>

<file path="scripts/autoFixLoop.js">
import { execSync } from "child_process";
import fs from "fs";
import dotenv from "dotenv";
import { Letta } from "@letta-ai/letta-client";

dotenv.config();

const client = new Letta({
  apiKey: process.env.LETTA_API_KEY,
  projectID: process.env.LETTA_PROJECT_ID,
});

const agentId = fs.existsSync(".letta_agent_id")
  ? fs.readFileSync(".letta_agent_id", "utf8").trim()
  : null;

const AUTO_APPLY = process.env.AUTO_APPLY === "true";
const MAX_ATTEMPTS = 3;

async function sendToLetta(payload) {
  const response = await client.agents.messages.create(agentId, {
    input: payload,
  });
  return response?.messages?.map((m) => m.text || m.content).join("\n") || "";
}

export async function autoFix() {
  if (!agentId) {
    console.error("No agent id found. Run createAgent.js first.");
    return;
  }

  for (let i = 0; i < MAX_ATTEMPTS; i++) {
    console.log(`\n--- Attempt ${i + 1}/${MAX_ATTEMPTS} ---`);

    try {
      const result = execSync("npm test", { stdio: "pipe", encoding: "utf8" });
      console.log("‚úÖ Tests passed!");
      console.log(result);
      return true;
    } catch (err) {
      const logs = err.stdout?.toString() || err.stderr?.toString() || "";
      console.log("‚ùå Tests failed. Asking Letta for help...");

      const prompt = `Tests are failing. Here are the logs:

${logs}

Please analyze and return a JSON response with this structure:
{
  "diagnosis": "what went wrong",
  "root_cause": "why it happened",
  "fix_steps": ["step 1", "step 2"],
  "code_patch": "unified diff patch if applicable",
  "risk": "low/medium/high",
  "confidence": 0.0-1.0
}

Only output valid JSON.`;

      const response = await sendToLetta(prompt);
      console.log("\nLetta response:", response);

      // Try to parse JSON response
      try {
        const jsonMatch = response.match(/\{[\s\S]*\}/);
        if (jsonMatch) {
          const parsed = JSON.parse(jsonMatch[0]);

          if (parsed.code_patch && AUTO_APPLY && parsed.confidence >= 0.8) {
            console.log("Applying patch (confidence:", parsed.confidence, ")");
            fs.writeFileSync("temp_fix.patch", parsed.code_patch, "utf8");
            try {
              execSync("git apply temp_fix.patch", { stdio: "inherit" });
              console.log("Patch applied. Re-running tests...");
            } catch (applyErr) {
              console.log("Failed to apply patch:", applyErr.message);
            }
          } else if (parsed.code_patch) {
            console.log("\nüìã Suggested patch (AUTO_APPLY=false):");
            console.log(parsed.code_patch);
            fs.writeFileSync("suggested_fix.patch", parsed.code_patch, "utf8");
            console.log("Saved to suggested_fix.patch - review and apply manually.");
            return false;
          }
        }
      } catch (parseErr) {
        console.log("Could not parse JSON response. Manual review needed.");
        return false;
      }
    }
  }

  console.log(`\n‚ö†Ô∏è Max attempts (${MAX_ATTEMPTS}) reached. Manual intervention needed.`);
  return false;
}

// Run if called directly
if (process.argv[1].includes("autoFixLoop")) {
  autoFix().catch(console.error);
}
</file>

<file path="scripts/createAgent.js">
import fs from "fs";
import dotenv from "dotenv";
import { Letta } from "@letta-ai/letta-client";

dotenv.config();

const apiKey = process.env.LETTA_API_KEY;
const projectID = process.env.LETTA_PROJECT_ID || undefined;

if (!apiKey || apiKey === "sk-...") {
  console.error("Please set LETTA_API_KEY in .env");
  process.exit(1);
}

const client = new Letta({ apiKey, projectID });

async function main() {
  try {
    const agent = await client.agents.create({
      model: "openai/gpt-4o-mini",  // Better context window support
      embedding: "openai/text-embedding-ada-002",
      memory_blocks: [
        {
          label: "persona",
          description: "Agent persona: helpful, safety-first, always explain changes.",
          value:
            "You are a careful coding assistant. Produce safe diffs, propose tests, and always output a suggested git commit message in the format DDMMYY - <short message> when you present a patch.",
        },
        {
          label: "project_rules",
          description: "General best-practices and style rules for all projects.",
          value:
            "Rule: always create small commits. Rule: run tests before commit. Rule: use 'main' as default branch unless repo has 'master'. Rule: generate commit messages as DDMMYY - Proper message.",
        },
        {
          label: "dev_commands",
          description: "Dev commands: how to run tests/build locally for this project",
          value:
            "test: npm test; build: npm run build; lint: npm run lint (if present). If unknown, ask the user: how do I run tests?",
        },
      ],
    });

    fs.writeFileSync(".letta_agent_id", agent.id, "utf8");
    console.log("Created agent:", agent.id);
  } catch (err) {
    console.error("Error creating agent:", err);
  }
}

main();
</file>

<file path="scripts/dispatch-cli.js">
// scripts/dispatch-cli.js
import fs from "fs";
import path from "path";
import dotenv from "dotenv";
import { fileURLToPath } from "url";
import { dispatch } from "./dispatcher.js";

dotenv.config();

const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

async function main() {
  const args = process.argv.slice(2);
  if (!args[0]) {
    console.error("Usage: node scripts/dispatch-cli.js <event-file-path> [repo-root]");
    process.exit(1);
  }

  const eventPath = path.resolve(args[0]);
  const repoRoot = args[1] ? path.resolve(args[1]) : process.cwd();

  if (!fs.existsSync(eventPath)) {
    console.error("Event file not found:", eventPath);
    process.exit(2);
  }

  console.log("Dispatching event:", eventPath);
  console.log("Target repo root:", repoRoot);

  try {
    const outdir = await dispatch(eventPath, repoRoot);
    console.log("Dispatch complete. Suggestion saved to:", outdir);
    process.exit(0);
  } catch (err) {
    console.error("Dispatch error:", err);
    process.exit(3);
  }
}

main();
</file>

<file path="scripts/dispatcher.js">
import fs from "fs-extra";
import path from "path";
import dotenv from "dotenv";
import { Letta } from "@letta-ai/letta-client";
import dayjs from "dayjs";
import { selectTemplate } from "./selector.js";

dotenv.config();

const apiKey = process.env.LETTA_API_KEY;
const projectID = process.env.LETTA_PROJECT_ID;
const agentId = fs.existsSync(".letta_agent_id")
  ? fs.readFileSync(".letta_agent_id", "utf8").trim()
  : null;
const client = new Letta({ apiKey, projectID });

if (!agentId) {
  console.error("No .letta_agent_id found. Run createAgent.js first.");
  process.exit(1);
}

function replaceTokens(template, tokens) {
  return template.replace(/\{\{([^}]+)\}\}/g, (_, k) => tokens[k.trim()] || "");
}

export async function dispatch(eventFilePath, repoRoot = ".") {
  const tplPath = await selectTemplate(eventFilePath);
  if (!tplPath) {
    console.log("No matching template for", eventFilePath);
    return null;
  }

  const tplRaw = await fs.readFile(tplPath, "utf8");
  const filled = replaceTokens(tplRaw, {
    event_file: eventFilePath,
    repo_root: repoRoot,
    LOGS: await fs.readFile(eventFilePath, "utf8"),
    PROJECT_CONTEXT: "Node.js project",
  });

  console.log("Using template:", tplPath);
  const response = await client.agents.messages.create(agentId, {
    input: filled,
  });

  // Create suggestions folder
  const stamp = dayjs().format("YYYYMMDD_HHmmss");
  const outDir = path.join("suggestions", stamp);
  await fs.ensureDir(outDir);

  // Save raw inputs and agent replies
  await fs.writeFile(path.join(outDir, "template.txt"), filled, "utf8");
  await fs.writeFile(
    path.join(outDir, "event.txt"),
    await fs.readFile(eventFilePath, "utf8"),
    "utf8"
  );

  // Save messages
  const text =
    response?.messages
      ?.map((m) => m.text || m.content || JSON.stringify(m))
      .join("\n\n---\n\n") || "";
  await fs.writeFile(path.join(outDir, "agent-response.txt"), text, "utf8");

  // If agent included a unified diff block, try extract and save
  const diffMatch = text.match(/(^---\s*a\/[\s\S]*?)(?=\n\n|$)/m);
  if (diffMatch) {
    await fs.writeFile(
      path.join(outDir, "suggested.patch"),
      diffMatch[0],
      "utf8"
    );
  }

  // If agent output contains Best practice lines, save them
  const bestPractices = text
    .split("\n")
    .filter((l) => /^Best practice:/i.test(l));
  if (bestPractices.length) {
    await fs.writeFile(
      path.join(outDir, "best-practices.txt"),
      bestPractices.join("\n"),
      "utf8"
    );
  }

  console.log("Saved suggestion to", outDir);
  return outDir;
}

// CLI usage: node scripts/dispatcher.js path/to/event.txt
if (process.argv[2]) {
  dispatch(process.argv[2], process.cwd()).catch(console.error);
}

export default dispatch;
</file>

<file path="scripts/generateCommitMsg.js">
import fs from "fs";
import dotenv from "dotenv";
import { Letta } from "@letta-ai/letta-client";
import dayjs from "dayjs";

dotenv.config();

const client = new Letta({
  apiKey: process.env.LETTA_API_KEY,
  projectID: process.env.LETTA_PROJECT_ID,
});

const agentId = fs.existsSync(".letta_agent_id")
  ? fs.readFileSync(".letta_agent_id", "utf8").trim()
  : null;

if (!agentId) {
  console.error("No agent id found");
  process.exit(1);
}

async function generate(summary) {
  if (!summary) {
    console.error(
      'Usage: node scripts/generateCommitMsg.js "Short description of change"'
    );
    process.exit(1);
  }

  const response = await client.agents.messages.create(agentId, {
    input: `Prepare a git commit subject for this change: ${summary}\nRemember: the commit message must be a single short line formatted as DDMMYY - <message>. Only output the commit message line.`,
  });

  const agentText =
    response?.messages?.map((m) => m.text || m.content).join("\n") || "";

  const today = dayjs().format("DDMMYY");
  let final = agentText.split("\n").find(Boolean) || `${today} - ${summary}`;

  // Ensure it starts with date
  if (!/^\d{6}\s*-\s*/.test(final)) {
    final = `${today} - ${final}`;
  }

  fs.writeFileSync(".git_commit_message.txt", final, "utf8");
  console.log("Commit message prepared in .git_commit_message.txt:");
  console.log(final);
}

generate(process.argv.slice(2).join(" ")).catch(console.error);
</file>

<file path="scripts/memory.js">
import fs from "fs";

const SHORT_TERM_PATH = "memory/short_term.json";
const LONG_TERM_PATH = "memory/long_term.json";

export function loadMemory() {
  return {
    short: JSON.parse(fs.readFileSync(SHORT_TERM_PATH, "utf8")),
    long: JSON.parse(fs.readFileSync(LONG_TERM_PATH, "utf8")),
  };
}

export function saveShort(entry) {
  const mem = JSON.parse(fs.readFileSync(SHORT_TERM_PATH, "utf8"));
  mem.push({
    ...entry,
    timestamp: Date.now(),
  });
  // Keep only last 50 entries
  if (mem.length > 50) {
    mem.splice(0, mem.length - 50);
  }
  fs.writeFileSync(SHORT_TERM_PATH, JSON.stringify(mem, null, 2), "utf8");
}

export function saveLong(key, value) {
  const mem = JSON.parse(fs.readFileSync(LONG_TERM_PATH, "utf8"));
  mem[key] = value;
  fs.writeFileSync(LONG_TERM_PATH, JSON.stringify(mem, null, 2), "utf8");
}

export function addCommonFailure(failure) {
  const mem = JSON.parse(fs.readFileSync(LONG_TERM_PATH, "utf8"));
  if (!mem.common_failures) {
    mem.common_failures = [];
  }
  mem.common_failures.push({
    ...failure,
    timestamp: Date.now(),
  });
  fs.writeFileSync(LONG_TERM_PATH, JSON.stringify(mem, null, 2), "utf8");
}

// CLI usage
if (process.argv[2] === "show") {
  console.log(JSON.stringify(loadMemory(), null, 2));
}
</file>

<file path="scripts/remember.js">
import fs from "fs";
import dotenv from "dotenv";
import { Letta } from "@letta-ai/letta-client";

dotenv.config();

const client = new Letta({
  apiKey: process.env.LETTA_API_KEY,
  projectID: process.env.LETTA_PROJECT_ID,
});

const agentId = fs.existsSync(".letta_agent_id")
  ? fs.readFileSync(".letta_agent_id", "utf8").trim()
  : null;

if (!agentId) {
  console.error("No agent id found");
  process.exit(1);
}

async function remember(note) {
  if (!note) {
    console.error('Usage: node scripts/remember.js "We use ESLint rule X"');
    process.exit(1);
  }
  const resp = await client.agents.messages.create(agentId, {
    input: `/remember ${note}`,
  });
  console.log(
    "Remember response:",
    resp?.messages?.[0]?.text || JSON.stringify(resp)
  );
}

remember(process.argv.slice(2).join(" ")).catch(console.error);
</file>

<file path="scripts/router.js">
import fs from "fs";

// Map event types to agent roles
const routingRules = {
  test_failure: ["debugger", "tester"],
  runtime_error: ["debugger"],
  lint_error: ["reviewer"],
  refactor_request: ["refactorer", "reviewer"],
  ci_failure: ["debugger", "reviewer"],
};

export function route(eventType) {
  return routingRules[eventType] || ["debugger"];
}

export function loadAgentConfig(role) {
  const configPath = `agents/${role}.agent.json`;
  if (fs.existsSync(configPath)) {
    return JSON.parse(fs.readFileSync(configPath, "utf8"));
  }
  return { role, goal: "General assistance", output: ["response"] };
}

// CLI usage: node scripts/router.js test_failure
if (process.argv[2]) {
  const eventType = process.argv[2];
  const agents = route(eventType);
  console.log(`Event: ${eventType}`);
  console.log(`Routed to agents: ${agents.join(", ")}`);
  agents.forEach((role) => {
    const config = loadAgentConfig(role);
    console.log(`\n${role}:`, config);
  });
}

export default route;
</file>

<file path="scripts/selector.js">
import fs from "fs";
import path from "path";
import { readFile } from "fs/promises";
import { minimatch } from "minimatch";

const mapping = JSON.parse(fs.readFileSync("mapping.json", "utf-8"));

// Extended mapping with pattern rules
const patternRules = [
  {
    name: "failing-test",
    match: {
      pathPattern: "tests/*.test.js",
      contentRegex: "FAIL|failing|AssertionError",
    },
    template: "templates/test_failure.txt",
    priority: 10,
  },
  {
    name: "lint-error",
    match: {
      pathPattern: "ci/lint-report.json",
      contentRegex: "eslint|lint",
    },
    template: "templates/lint.txt",
    priority: 9,
  },
  {
    name: "runtime-error",
    match: {
      pathPattern: "logs/errors.log",
      contentRegex: "TypeError|ReferenceError|uncaught",
    },
    template: "templates/runtime.txt",
    priority: 8,
  },
];

export async function selectTemplate(eventPath) {
  const content = await readFile(eventPath, "utf8");
  const candidates = [];

  for (const rule of patternRules) {
    const pathMatch = minimatch(
      path.basename(eventPath),
      rule.match.pathPattern || "*"
    );
    const regex = rule.match.contentRegex
      ? new RegExp(rule.match.contentRegex, "i")
      : null;
    const contentMatch = regex ? regex.test(content) : true;
    if (pathMatch && contentMatch) {
      candidates.push(rule);
    }
  }

  candidates.sort((a, b) => (b.priority || 0) - (a.priority || 0));
  return candidates.length ? candidates[0].template : null;
}

export default selectTemplate;
</file>

<file path="scripts/sendMessage.js">
import fs from "fs";
import dotenv from "dotenv";
import { Letta } from "@letta-ai/letta-client";

dotenv.config();

const apiKey = process.env.LETTA_API_KEY;
const projectID = process.env.LETTA_PROJECT_ID || undefined;

if (!apiKey || apiKey === "sk-...") {
  console.error("Please set LETTA_API_KEY in .env");
  process.exit(1);
}

const client = new Letta({ apiKey, projectID });
const agentId = fs.existsSync(".letta_agent_id")
  ? fs.readFileSync(".letta_agent_id", "utf8").trim()
  : null;

if (!agentId) {
  console.error("Agent id not found. Run scripts/createAgent.js first.");
  process.exit(1);
}

// Load template if type provided
function loadTemplate(type) {
  const mapping = JSON.parse(fs.readFileSync("mapping.json", "utf-8"));
  const file = mapping[type];
  if (!file) return null;
  return fs.readFileSync(file, "utf-8");
}

function fillTemplate(template, vars) {
  let output = template;
  for (const key in vars) {
    output = output.replaceAll(`{{${key}}}`, vars[key] || "");
  }
  return output;
}

async function send(input) {
  const response = await client.agents.messages.create(agentId, { input });

  if (response && response.messages) {
    for (const m of response.messages) {
      console.log("AGENT:", m.text || m.content || JSON.stringify(m));
    }
  }
  return response;
}

// CLI usage:
// node scripts/sendMessage.js "Hello"
// node scripts/sendMessage.js test_failure path/to/log.txt
const arg1 = process.argv[2];
const arg2 = process.argv[3];

let payload;

// Check if arg1 is a template type
const template = arg1 ? loadTemplate(arg1) : null;
if (template && arg2) {
  const logs = fs.existsSync(arg2) ? fs.readFileSync(arg2, "utf-8") : "";
  payload = fillTemplate(template, {
    LOGS: logs,
    CODE: logs,
    PROJECT_CONTEXT: "Node.js project using CI automation",
  });
} else {
  payload = process.argv.slice(2).join(" ") || "Hello, what do you remember about this repo?";
}

send(payload).catch(console.error);
</file>

<file path="scripts/watcher.js">
import chokidar from "chokidar";
import path from "path";
import { dispatch } from "./dispatcher.js";
import dotenv from "dotenv";

dotenv.config();

// Use TARGET_REPO env var to watch another repo (otherwise defaults to current letta repo)
const TARGET_REPO = process.env.TARGET_REPO || process.cwd();

// Patterns relative to TARGET_REPO to watch for events
const WATCH_PATHS = [
  path.join(TARGET_REPO, "tests", "*.test.js"),
  path.join(TARGET_REPO, "src", "**", "*.js"),
  path.join(TARGET_REPO, "src", "**", "*.jsx"),
  path.join(TARGET_REPO, "ci", "*.json"),
  path.join(TARGET_REPO, "logs", "errors.log"),
  "events/*.log",  // Also watch local events folder
  "signals/*.json"
];

console.log("Letta watcher starting...");
console.log("Target repo:", TARGET_REPO);
console.log("Watching paths:");
WATCH_PATHS.forEach(p => console.log("  ", p));

const watcher = chokidar.watch(WATCH_PATHS, { 
  ignoreInitial: true,
  awaitWriteFinish: { stabilityThreshold: 300, pollInterval: 100 }
});

watcher.on("change", async (filePath) => {
  console.log("Detected change:", filePath);
  try {
    const suggestionDir = await dispatch(filePath, TARGET_REPO);
    if (suggestionDir) {
      console.log(
        "Suggestion placed at:",
        suggestionDir,
        "‚Äî review before applying."
      );
    }
  } catch (e) {
    console.error("Watcher error:", e);
  }
});

watcher.on("add", async (filePath) => {
  console.log("New event file:", filePath);
  try {
    await dispatch(filePath, TARGET_REPO);
  } catch (e) {
    console.error("Watcher add error:", e);
  }
});

console.log("");
console.log("Watcher running. Press Ctrl+C to stop.");
console.log("Now edit files in your project or drop .log files into events/ folder.");
</file>

<file path="templates/ci_failure.txt">
You are a CI/CD expert.

Context: Pipeline failed.

Steps:
1. Identify which stage failed
2. Explain likely causes
3. Suggest fixes
4. Suggest prevention strategy

CI logs:
{{LOGS}}
</file>

<file path="templates/formatting.txt">
You are a formatting assistant.

Tasks:
- Apply standard formatting
- Improve readability
- Keep logic unchanged

Code:
{{CODE}}
</file>

<file path="templates/lint.txt">
You are a code quality assistant.

A linter reported violations.

Tasks:
1. Explain why each rule failed
2. Provide corrected code
3. Suggest configuration improvements

Lint output:
{{LOGS}}
</file>

<file path="templates/refactor.txt">
You are a senior software engineer.

Goal: Improve code readability, structure, and maintainability.

Rules:
- Do NOT change behavior
- Keep logic equivalent
- Explain why changes help

Code:
{{CODE}}
</file>

<file path="templates/runtime.txt">
You are debugging a runtime failure.

Steps:
1. Identify exception type
2. Explain root cause
3. Suggest fix
4. Mention monitoring improvements

Runtime logs:
{{LOGS}}
</file>

<file path="templates/test_failure.txt">
You are an expert debugging assistant.

Context:
- Tests are failing.
- Stack trace and logs are provided below.

Goals:
1. Identify root cause
2. Explain failure simply
3. Suggest minimal fix
4. Warn about side effects

Logs:
{{LOGS}}

Project info:
{{PROJECT_CONTEXT}}
</file>

</files>
